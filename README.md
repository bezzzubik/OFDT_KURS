# Предустановка
Для работы программы необходима библиотека [fftw3.h](https://www.fftw.org/index.html).
Скачать ее можно по [ссылке](https://www.fftw.org/fftw-3.3.10.tar.gz). Либо можно посмотреть другие версии библиотеки по [ссылке](https://www.fftw.org/download.html). 

Установка библиотеки:
Разархивируйте папку в корень;

В папке через консоль запустить:
```bash
./configure
make -j
make install
```
# Запуск
Обязательные флаги при компиляции: ```-lfftw3, -lm ```

# Тестирование
Основные моменты при тестировании:
____
### N
Как утверждается, ОБПФ желательно иметь степень 2 для более быстрого преобразования. Чтобы изменить число поднесущих, следует изменить параметр N.

Его главное ограничение - он должен быть больше или равен постоянной COUNT_CADR, которая определяет число передаваемых в данный момент полезных битов информации.
____
### Флаги плана
Перед выполнением ОБПФ код строит план вычислений через функцию ```fftw_plan_dft_1d(N, in, out, flag1, flag2) ```

Допускается изменение flag2 для оптимизации и выбора лучшего алгоритма описания плана:

* Построение плана:

	* FFTW_ESTIMATE: Быстрое создание плана, не сильно оптимальное выполнение (О)БПФ

    * FFTW_MEASURE: Ищет более оптимальный алгоритм. 
				Создание плана займет время, выполнение (О)БПФ будет быстрее

    * FFTW_PATIENT: Ищет еще более оптимальный алгоритм. 
				Создание будет еще дольше, но будет еще более высокая производительность (О)БПФ.

    * FFTW_EXHAUSTIVE: Перебор всех имеющихся алгоритмов и выбор наилучшего. 
				Самый затратный по времени создания плана и самый эффективный по выполнению (О)БПФ.

* Управления памятью:
    * FFTW_IN_PLACE: Входные и выходные данные находятся в одном и том же массиве. 
				Экономит память, но изменяет исходные данные.

    * FFTW_PRESERVE_INPUT: Гарантирует, что входные данные не будут изменены в процессе преобразования. 
				Может немного замедлить выполнение.

    * FFTW_DESTROY_INPUT: Разрешает FFTW изменять входные данные для оптимизации преобразования. 
				Может ускорить выполнение, но входные данные будут потеряны.
			
* Доп флаги:
    * FFTW_UNALIGNED: Входные и/или выходные данные могут быть не выровнены в памяти. 
				Использовать, если используется malloc() вместо fftw_malloc() для выделения памяти.

    * FFTW_CONSERVE_MEMORY: Пытается использовать меньше памяти, но может немного замедлить выполнение.

    * FFTW_TRANSPOSED_ORDER: Указывает, что выходные данные должны быть транспонированы.
____

# 01.04.25
В данный момент код не до конца оптимизирован. Весь цикл обработки проверен. Преобразованные данные правильно восстанавливались.

## Тестирование
Компиляция без дополнительных флагов оптимизации.

Флаги плана: FFTW_EXHAUSTIVE | FFTW_DESTROY_INPUT
___
### Тест 1
Количество тестов: 100 

Данные для тестов: "KKAAKK" 

Флаги: FFTW_EXHAUSTIVE | FFTW_DESTROY_INPUT

N = 12

Среднее количество проходов за одну секунду: 5 664 099.
___
### Тест 2
Количество тестов: 100 

Данные для тестов: "KKAAKK" 

Флаги: FFTW_EXHAUSTIVE

N = 12

Среднее количество проходов за одну секунду: 5 852 486.
____
### Тест 3
Количество тестов: 300 

Данные для тестов: "KKAAKK" 

Флаги: FFTW_EXHAUSTIVE

N = 12

Среднее количество проходов за одну секунду: 5 755 142.
___

### Тест 4
Количество тестов: 100 

Данные для тестов: "KKAAKK" 

Флаги: FFTW_EXHAUSTIVE | FFTW_DESTROY_INPUT

N = 16

Среднее количество проходов за одну секунду: 4 968 625.
___
### Тест 5
Количество тестов: 100 

Данные для тестов: "KKAAKK" 

Флаги: FFTW_EXHAUSTIVE

N = 16

Среднее количество проходов за одну секунду: 5 005 508.
___
### Тест 6
Количество тестов: 100 

Данные для тестов: "KKAAKK" 

Флаги: FFTW_PATIENT

N = 12

Среднее количество проходов за одну секунду: 5 655 578.
___