# Предустановка
Для работы программы необходима библиотека [fftw3.h](https://www.fftw.org/index.html).
Скачать ее можно по [ссылке](https://www.fftw.org/fftw-3.3.10.tar.gz). Либо можно посмотреть другие версии библиотеки по [ссылке](https://www.fftw.org/download.html). 

Установка библиотеки:
Разархивируйте папку в корень;

В папке через консоль запустить:
```bash
./configure
make -j
make install
```
# Запуск
Обязательные флаги при компиляции: ```-lfftw3, -lm ```

# Тестирование
Основные моменты при тестировании:
____
### N
Как утверждается, ОБПФ желательно иметь степень 2 для более быстрого преобразования. Чтобы изменить число поднесущих, следует изменить параметр N.

Его главное ограничение - он должен быть больше или равен постоянной COUNT_CADR, которая определяет число передаваемых в данный момент полезных битов информации.
____
### Флаги плана
Перед выполнением ОБПФ код строит план вычислений через функцию ```fftw_plan_dft_1d(N, in, out, flag1, flag2) ```

Допускается изменение flag2 для оптимизации и выбора лучшего алгоритма описания плана:

* Построение плана:

	* FFTW_ESTIMATE: Быстрое создание плана, не сильно оптимальное выполнение (О)БПФ

    * FFTW_MEASURE: Ищет более оптимальный алгоритм. 
				Создание плана займет время, выполнение (О)БПФ будет быстрее

    * FFTW_PATIENT: Ищет еще более оптимальный алгоритм. 
				Создание будет еще дольше, но будет еще более высокая производительность (О)БПФ.

    * FFTW_EXHAUSTIVE: Перебор всех имеющихся алгоритмов и выбор наилучшего. 
				Самый затратный по времени создания плана и самый эффективный по выполнению (О)БПФ.

* Управления памятью:
    * FFTW_IN_PLACE: Входные и выходные данные находятся в одном и том же массиве. 
				Экономит память, но изменяет исходные данные.

    * FFTW_PRESERVE_INPUT: Гарантирует, что входные данные не будут изменены в процессе преобразования. 
				Может немного замедлить выполнение.

    * FFTW_DESTROY_INPUT: Разрешает FFTW изменять входные данные для оптимизации преобразования. 
				Может ускорить выполнение, но входные данные будут потеряны.
			
* Доп флаги:
    * FFTW_UNALIGNED: Входные и/или выходные данные могут быть не выровнены в памяти. 
				Использовать, если используется malloc() вместо fftw_malloc() для выделения памяти.

    * FFTW_CONSERVE_MEMORY: Пытается использовать меньше памяти, но может немного замедлить выполнение.

    * FFTW_TRANSPOSED_ORDER: Указывает, что выходные данные должны быть транспонированы.
____

# 01.04.25
В данный момент код не до конца оптимизирован. Весь цикл обработки проверен. Преобразованные данные правильно восстанавливались.

## Тестирование
Компиляция без дополнительных флагов оптимизации.

Флаги плана: FFTW_EXHAUSTIVE | FFTW_DESTROY_INPUT
___
### Тест 1
Количество тестов: 100 

Данные для тестов: "KKAAKK" 

Флаги: FFTW_EXHAUSTIVE | FFTW_DESTROY_INPUT

N = 12

Среднее количество проходов за одну секунду: 5 664 099.
___
### Тест 2
Количество тестов: 100 

Данные для тестов: "KKAAKK" 

Флаги: FFTW_EXHAUSTIVE

N = 12

Среднее количество проходов за одну секунду: 5 852 486.
____
### Тест 3
Количество тестов: 300 

Данные для тестов: "KKAAKK" 

Флаги: FFTW_EXHAUSTIVE

N = 12

Среднее количество проходов за одну секунду: 5 755 142.
___

### Тест 4
Количество тестов: 100 

Данные для тестов: "KKAAKK" 

Флаги: FFTW_EXHAUSTIVE | FFTW_DESTROY_INPUT

N = 16

Среднее количество проходов за одну секунду: 4 968 625.
___
### Тест 5
Количество тестов: 100 

Данные для тестов: "KKAAKK" 

Флаги: FFTW_EXHAUSTIVE

N = 16

Среднее количество проходов за одну секунду: 5 005 508.
___
### Тест 6
Количество тестов: 100 

Данные для тестов: "KKAAKK" 

Флаги: FFTW_PATIENT

N = 12

Среднее количество проходов за одну секунду: 5 655 578.
___

# 02.04.25
Установлен perf, для дальнейшего анализа оптимизации алгоритма будет использоваться автоматическая генерация данных.
Как идея добавить 2 поднесущие в начало (как начало сообщения) и в конец (как конец сообщения).

# 09.04.25
Разработка многопоточной версии выполнения алгоритма.

## Основные блоки:
* ### Генератор | void generate_bit():
    Имитирует входящий поток данных. Пока что на вход подается полноценный набор бит, который далее будет распараллелен и преобразован в необходимые данные.
    
    Нет нижнего ограничения, так как это иммитация канала, ограничения по скорости не требуются. Не страшно, если поток будет простаивать в ожидании доступа к переменной. 

* ### Распараллеливатель\упаковщик | void s2p():
    Принимает на вход поток бит, распараллеливает и упаковывает их для следующих блоков.
    
    Ограничения по скорости будут зависеть от скорости принятия и обработки блока mapper(). ПРИ ЭТОМ ОН НЕ ДОЛЖЕН УПИРАТЬСЯ В СКОРОСТЬ РАБОТЫ ГЕНЕРАТОРА (что в теории должно быть невозможно при правильной реализации)

* ### Модулятор\маппер | void mapper():
    Принимает упакованные биты, которые необходимо сопоставить с "звездной картой"(как пример, реализован 16-QAM, но в теории можно увеличить). На выходе дает комплексное число для последующего ОБПФ 
    
    Ограничения по скорости будут зависеть от скорости принятия и обработки блока IFFT. 

* ### ОБПФ | void ifft():
    Принимает поток комплексных чисел, который с помощью ОБПФ будет преобразован в данные, необходимые для передачи.
    
    Ограничения по скорости будут зависеть от собственной скорости работы(так как ОБПФ при больших числах может нагружать систему) и от скорости работы следующего блока p2s().

* ### Свертыватель | void p2s():
    Принимает данные, полученные после ОБПФ. Сворачивает данные нескольких потоков в один поток данных. 
    
    Ограничения по скорости будут зависеть от собственной скорости работы и от скоростей работы ОБПФ.

___
# 12.04.25
 * Формализован вывод, нужно проверить, как будет работать с регуляцией скорости потока.
 * Нужно организовать механизм оптимизации скорости потоков.
 * Возможно стоит исключить из расчетов время копирования данных из "канала".

## Идеи
* Разработать механизм изменения частоты работы потока в зависимости от времени простаивания в ожидании.
* Проанализировать данные через perf, возможно объединить некоторые блоки в зависимости от производительности (к примеру, распараллеливатель и модулятор).
* НАПИСАТЬ БЛОК-СХЕМУ, ОРГАНИЗОАВТЬ КОРРЕКТНУЮ РЕГУЛЯЦИЮ СКОРОСТИ РАБОТЫ ПОТОКА